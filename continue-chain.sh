#!/bin/bash
#
# Pick a file and run it.  This mostly implements a naming convention
# to simplify runing several chains in parallel.  It expects that all
# of the jobs are going to be run in a single directory.  The script
# works fine with a single chain, but is intended to handle lots (and
# lots) of parallel chains.  The intended use case is when you have
# access to a cluster with >>100 available cores so you can run
# several hundred parallel chains. This is run
#
#   continue-chain.sh [-N] basefile trials executable 
#
#    Option: -N -- Start a new epoch 001 file.
# 
#     basefile -- This is the name of a starting point for the chain.
#        It should be a file that has been generated by TSimpleMCMC,
#        and which contains the initial burning of the chain.  It is
#        typically going to be named something like [prefix].root where
#        the prefix is chosen by the user.
#
#     trials -- The number of trials to be run in this job.  These
#        trials start from the last state in basefile.
#
#     executable -- The name of an executable to be run.  It needs to
#        be run as follows (same as mcmc.exe)
#
#           executable trials outputfile inputfile
#
# An example of using this might be
#
# # Make three starting point files
# $ continue-chain.sh -N ../SimpleMCMC.root 10000 ../mcmc.exe
# $ continue-chain.sh -N ../SimpleMCMC.root 10000 ../mcmc.exe
# $ continue-chain.sh -N ../SimpleMCMC.root 10000 ../mcmc.exe
#
# # Run the the program eight more times.
# $ continue-chain.sh ../SimpleMCMC.root 10000 ../mcmc.exe
# $ continue-chain.sh ../SimpleMCMC.root 10000 ../mcmc.exe
# $ continue-chain.sh ../SimpleMCMC.root 10000 ../mcmc.exe
# $ continue-chain.sh ../SimpleMCMC.root 10000 ../mcmc.exe
# $ continue-chain.sh ../SimpleMCMC.root 10000 ../mcmc.exe
# $ continue-chain.sh ../SimpleMCMC.root 10000 ../mcmc.exe
# $ continue-chain.sh ../SimpleMCMC.root 10000 ../mcmc.exe
# $ continue-chain.sh ../SimpleMCMC.root 10000 ../mcmc.exe
#
# This produced output like
#
# $ ls
# SimpleMCMC_000_00000000_00000001_963556.closed.root
# SimpleMCMC_000_00000000_00000001_db1744.closed.root
# SimpleMCMC_000_00000000_00000001_e0bedb.closed.root
# SimpleMCMC_001_00000001_4daeb417_e0bedb.closed.root
# SimpleMCMC_001_00000001_6b8553dd_963556.closed.root
# SimpleMCMC_001_00000001_c34e97cb_db1744.closed.root
# SimpleMCMC_002_4daeb417_abf3ef80_1bb403.closed.root
# SimpleMCMC_002_6b8553dd_d3e878a8_86b981.closed.root
# SimpleMCMC_002_c34e97cb_ffd79c45_79e6da.open.root
# SimpleMCMC_003_abf3ef80_739a981b_d4fc43.open.root
# SimpleMCMC_003_d3e878a8_623ea8a7_3fc3db.open.root
# $
#
# The important part of the names are the "SimpleMCMC" which comes
# from the name of the input file on the command line.  It's the first
# input file for the chain.  The other important part is the first
# number "000" to "003" which gives the epoch of te file.  The 000
# epoch is just a hard link to the original input file
# (i.e. SimpleMCMC.root), so it those files can be deleted and should
# always be ignored.  Assuming enough steps per file, 001 epoch should
# be treated as burning files and the other files
# (i.e. "*.closed.root" and "*.open.root") can be added together to
# form a posterior distribution.  The rest of the name is there to
# help with forensic debugging.
#
# The File naming convention is:
#     prefix_epoch_parent-md5_child-md5_job-id_suffix
#
#  Prefix -- based on what the user provides.  This is for different
#  types of chains.
#
#  Epoch -- The number of "epochs" between this file and the first
#  file of the particular chain.  This is 3 characters (decimal)
#
#  Parent -- The md5sum value for the parent file.  This is the file
#  before the current file in the chain.  This is 8 characters
#
#  Child -- The md5sum value for this file.  This is 8 characters
#
#  Job -- A unique identifier for the current job.  This is 6 characters
#
#  Suffix -- One of
#     open.root -- This is the last file in a chain and can be extended
#     closed.root -- This is not the last file in a chain. Don't extend it
#     job.input.root -- An file being used as a starting point
#     job.running.root -- An output file being generated
#
# When started, this will rename one "[blah].open.root" to
# [blah]_job.input.root and run the job with output
# [blah]_job.running.root.  When the job finishes [blah]_job.input.root is
# renamed to [blah].closed.root and [blah]_job.running.root is renamed
# to [blah].open.root
#
#

#####################################
# Handle any input options
TEMP=$(getopt -o 'N' -n "$0" -- "$@")
if [ $? -ne 0 ]; then
    echo "Error ..."
    exit 1
fi
eval set -- "$TEMP"
unset TEMP
while true; do
    case "$1" in
        # Force a new epoch 001 file to be started.
	'-N')
            MAKE_NEW_FILE=yes
	    shift
	    continue;;
	'--')
	    shift
	    break;
    esac
done

#####################################
# Get the base file that provides the very first part of burn-in.
BASEFILE=$1; shift

if [ ! -f ${BASEFILE} ]; then
    echo The base file ${BASEFILE} is missing
    exit 1
fi

#####################################
# Get the number of trials to run in this job
TRIALS=$1; shift

if [ ${#TRIALS} == 0 ]; then
    echo The trials parameter is missing
    exit 1
fi

TRIALS=$(printf %d ${TRIALS} || echo NotAnInteger)
TRIALS=$(echo ${TRIALS} | grep -v NotAnInteger)

if [ ${#TRIALS} == 0 ]; then
    echo The trials parameter is not an integer
    exit 1
fi

####################################
# Get the executable you want to run.  This is a good place to modify
# and hardcode which program is going to run (copy continue-chain.sh
# to a new name).
EXECUTABLE=$1; shift
if [ ! -x ${EXECUTABLE} ]; then
    echo The file ${EXECUTABLE} is missing or cannot be run
    exit 1
fi

# This is a (fairly) unique hex number that identifies this job.  It's
# not really needed.
NEWJOB=$(uuidgen | md5sum | cut -c 1-6)

###################################
# Find an input file to read.
ORIGINAL=missing
INPUT=missing
while true; do
    for file in *.open.root; do
        if [ "x${MAKE_NEW_FILE}" == "xyes" ]; then
            break
        fi
        echo Looking at ${file}
        TRY=$(echo ${file} | sed s/.open.root/_${NEWJOB}.input.root/)
        echo Try ${TRY}
        mv ${file} ${TRY}
        sleep 1
        if [ -f ${TRY} ]; then
            ORIGINAL=${file}
            INPUT=${TRY}
            break
        fi
    done
    if [ -f ${INPUT} ]; then
        break
    fi
    if [ "x${MAKE_NEW_FILE}" != "xyes" ]; then
        echo You need to run this with -N first, or jobs need to finish.
        exit 1
    fi
    MAKE_NEW_FILE=no
    # Copy the base file into an "open file" with epoch zero and try
    # again.  The base should be named "${PREFIX}.root".  If the name
    # containes a "_" the field before that will become the prefix.
    PREFIX=$(echo ${BASEFILE} | cut -d_ -f 1 | sed s/.root//)
    NEWFILE=$(basename ${PREFIX}_000_00000000_00000001_${NEWJOB}.open.root)
    echo Copy $BASEFILE to ${NEWFILE}
    ln ${BASEFILE} ${NEWFILE}
    sleep 1
done

# A sanity check
if [ ! -f ${INPUT} ]; then
    echo The input file ${INPUT} is missing!?!
    exit 1
fi

################################################
# Parse the fields in the input file name
PREFIX=$(echo ${INPUT} | cut -d_ -f 1)
OLDEPOCH=$(echo ${INPUT} | cut -d_ -f 2)
GRANDPARENT=$(echo ${INPUT} | cut -d_ -f 3)
PARENT=$(echo ${INPUT} | cut -d_ -f 4)
OLDJOB=$(echo ${INPUT} | cut -d_ -f 5)

# Check the that input file is properly named!
CHECK=${PREFIX}_${OLDEPOCH}_${GRANDPARENT}_${PARENT}_${OLDJOB}_${NEWJOB}
if [ ! -f ${CHECK}.input.root ]; then
    echo Problem with input file name ${ORIGINAL}
    exit 1
fi

# Generate the new epoch for the file.
NEWEPOCH=$(printf %3.3d $(( $(echo ${OLDEPOCH} | sed s/0*//) + 1)) )

# Make the temporary name for the running file
RUNNING=${PREFIX}_${NEWEPOCH}_${PARENT}_unknown_${NEWJOB}.running.root

echo "#####################################################"
echo "Executable:      " ${EXECUTABLE}
echo "Temporary input: " ${INPUT}
echo "Temporary output:" ${RUNNING}
echo Trials: ${TRIALS}

echo "#####################################################"
COMMAND="${EXECUTABLE} ${TRIALS} ${RUNNING} ${INPUT}"
echo Command: ${COMMAND}
echo "#####################################################"

#################################################
# Run the job!  If the executable takes a different set of command
# line parameters, this is where the changes are made.
${COMMAND} || exit 1

# Make the final name for the file that was just used to start the chain.
CLOSED=${PREFIX}_${OLDEPOCH}_${GRANDPARENT}_${PARENT}_${OLDJOB}.closed.root
echo "Continued file:" ${CLOSED}

# Find the checksum value for the new file
CHILD=$(md5sum ${RUNNING} | cut -c 1-8)

# Make the final name for the file that was just run.
OPEN=${PREFIX}_${NEWEPOCH}_${PARENT}_${CHILD}_${NEWJOB}.open.root
echo "New file:      " ${OPEN}

# Move the temporary files to the final location
mv ${INPUT} ${CLOSED}
mv ${RUNNING} ${OPEN}
